"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SocketConnection = void 0;
const WebSocketWrapper_1 = require("../../utils/WebSocketWrapper");
const Time_1 = require("../../utils/Time");
const parseCustomTag_1 = require("../../utils/parseCustomTag");
const Transaction_1 = require("../Transaction");
const Timer_1 = require("../../utils/Timer");
const createPromise_1 = require("../../utils/createPromise");
const sleep_1 = require("../../utils/sleep");
class SocketConnection {
    constructor(url, callListener, socketId, XAPI) {
        this.connectedTime = null;
        this.lastReceivedMessage = null;
        this.capacity = [];
        this.queue = [];
        this.queueTimer = new Timer_1.Timer();
        this.connectionProgress = null;
        this.disconnectionProgress = null;
        this.socketId = socketId;
        this.callListener = callListener;
        this.XAPI = XAPI;
        this.WebSocket = new WebSocketWrapper_1.WebSocketWrapper(url);
        const pingTimer = new Timer_1.Timer();
        this.WebSocket.onOpen(() => {
            var _a, _b;
            this.connectedTime = new Time_1.Time();
            (_a = this.connectionProgress) === null || _a === void 0 ? void 0 : _a.resolve();
            (_b = this.disconnectionProgress) === null || _b === void 0 ? void 0 : _b.reject(new Error('onOpen'));
            pingTimer.setInterval(() => {
                this.status === 'CONNECTED' && this.loggedIn && this.XAPI.Socket.send.ping(this.socketId)
                    .catch(() => { });
            }, 14500);
            this.callListener('onOpen', [socketId, this]);
        });
        this.WebSocket.onClose(() => {
            var _a, _b;
            this.connectedTime = null;
            (_a = this.disconnectionProgress) === null || _a === void 0 ? void 0 : _a.resolve();
            (_b = this.connectionProgress) === null || _b === void 0 ? void 0 : _b.reject(new Error('onClose'));
            pingTimer.clear();
            this.callListener('onClose', [socketId, this]);
        });
        this.WebSocket.onMessage((json) => {
            this.lastReceivedMessage = new Time_1.Time();
            try {
                const message = JSON.parse(json.toString().trim());
                this.XAPI.counter.count(['data', 'SocketConnection', 'incomingData'], json.length);
                this.handleMessage(message, new Time_1.Time(), json, socketId);
            }
            catch (e) {
                this.XAPI.counter.count(['error', 'SocketConnection', 'handleMessage']);
                this.callListener('handleMessage', [{
                        command: null,
                        error: e,
                        time: new Time_1.Time(),
                        transactionId: null,
                        json,
                        socketId,
                    }]);
            }
        });
        this.WebSocket.onError((error) => {
            this.connectionProgress && this.connectionProgress.reject(error);
            this.callListener('handleMessage', [{
                    command: null,
                    error,
                    time: new Time_1.Time(),
                    transactionId: null,
                    json: null,
                    socketId,
                }]);
        });
    }
    get status() {
        return this.WebSocket.connecting ? 'CONNECTING' : (this.WebSocket.status ? 'CONNECTED' : 'DISCONNECTED');
    }
    connect(timeoutMs) {
        if (this.WebSocket.status) {
            throw new Error('already connected');
        }
        if (this.connectionProgress) {
            return this.connectionProgress.promise;
        }
        const t = new Transaction_1.Transaction();
        const timer = new Timer_1.Timer();
        timer.setTimeout(() => {
            var _a;
            (_a = this.connectionProgress) === null || _a === void 0 ? void 0 : _a.reject(new Error('timeout'));
            this.close();
        }, timeoutMs);
        this.connectionProgress = t;
        this.WebSocket.connect();
        return t.promise.catch(e => {
            timer.clear();
            this.connectionProgress = null;
            throw e;
        }).then((r) => {
            timer.clear();
            this.connectionProgress = null;
            return r;
        });
    }
    close() {
        if (!this.WebSocket.status && !this.WebSocket.connecting) {
            return Promise.resolve();
        }
        if (this.disconnectionProgress) {
            return this.disconnectionProgress.promise;
        }
        const t = new Transaction_1.Transaction();
        this.disconnectionProgress = t;
        this.WebSocket.close();
        return t.promise.catch(e => {
            this.disconnectionProgress = null;
            throw e;
        }).then((r) => {
            this.disconnectionProgress = null;
            return r;
        });
    }
    cleanQueue() {
        return __awaiter(this, void 0, void 0, function* () {
            for (; this.queue.length > 0;) {
                if (this.capacity[4].elapsedMs() < 1000) {
                    break;
                }
                const jsons = this.queue.splice(0, 1);
                if (jsons.length === 1) {
                    if (jsons[0].transaction.state.createdAt.elapsedMs() > 9000) {
                        jsons[0].promise.reject(new Error('timeout due to queue overloaded'));
                        this.XAPI.counter.count(['data', 'SocketConnection', 'send', 'queue', 'timeout'], 1);
                    }
                    else {
                        try {
                            this.send(jsons[0].transaction, jsons[0].promise);
                            if (this.queue.length > 0) {
                                yield (0, sleep_1.sleep)(250);
                            }
                        }
                        catch (e) {
                        }
                    }
                }
                else {
                    break;
                }
            }
        });
    }
    callCleaner(elapsedMs) {
        return this.queueTimer.setTimeout(() => __awaiter(this, void 0, void 0, function* () {
            yield this.cleanQueue();
            if (this.queue.length > 0) {
                return yield this.callCleaner(this.capacity[4].elapsedMs());
            }
            return undefined;
        }), 1000 - elapsedMs);
    }
    send(transaction, promise) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const _promise = promise ? promise : (0, createPromise_1.createPromise)();
            if (transaction.state.json.length > 1000) {
                _promise.reject(new Error('Each command invocation should not contain more than 1kB of data.'));
                return _promise.promise;
            }
            try {
                const elapsedMs = this.capacity.length > 4 ? this.capacity[4].elapsedMs() : 1001;
                if (elapsedMs < 1000) {
                    this.XAPI.counter.count(['data', 'SocketConnection', 'send', 'queue', 'add'], 1);
                    if (transaction.state.priority) {
                        const index = this.queue.findIndex(i => !i.transaction.state.priority);
                        this.queue.splice(index === -1 ? 0 : index, 0, { transaction, promise: _promise });
                    }
                    else {
                        this.queue.push({ transaction, promise: _promise });
                    }
                    this.queueTimer.isNull() && (yield this.callCleaner(elapsedMs));
                    return _promise.promise;
                }
                const time = new Time_1.Time();
                if (this.capacity.length > 20) {
                    this.capacity = [time, ...this.capacity.slice(0, 4)];
                }
                else {
                    this.capacity.unshift(time);
                }
                yield this.WebSocket.send(transaction.state.json);
                this.XAPI.counter.count(['data', 'SocketConnection', 'send', 'waitingTime'], transaction.state.createdAt.elapsedMs());
                this.XAPI.logger.debug({ source: 'src/v2/core/Socket/SocketConnection.ts', function: 'send', data: {
                        command: transaction.state.command,
                        args: transaction.state.command === 'login' ? Object.assign(Object.assign({}, transaction.state.args), { password: typeof ((_b = (_a = transaction.state) === null || _a === void 0 ? void 0 : _a.args) === null || _b === void 0 ? void 0 : _b.password) == 'string' ? '*' : undefined }) : transaction.state.args,
                    } });
                transaction.setState({
                    sent: new Time_1.Time()
                });
                this.XAPI.counter.count(['data', 'SocketConnection', 'outgoingData'], transaction.state.json.length);
                _promise.resolve(time);
            }
            catch (e) {
                _promise.reject(e);
            }
            return _promise.promise;
        });
    }
    handleMessage(message, time, json, socketId) {
        if (message.status) {
            const returnData = message.streamSessionId === undefined
                ? message.returnData
                : { streamSessionId: message.streamSessionId };
            const { transactionId, command } = typeof message.customTag === 'string'
                ? (0, parseCustomTag_1.parseCustomTag)(message.customTag)
                : (0, parseCustomTag_1.parseCustomTag)(null);
            if (transactionId !== null && command !== null) {
                this.callListener('handleMessage', [{ command, returnData, time, transactionId, json, socketId }]);
            }
            else {
                this.callListener('handleMessage', [{
                        command,
                        error: { errorDescr: 'Received a message without valid customTag', errorCode: -1 },
                        time,
                        transactionId,
                        json,
                        socketId,
                    }]);
            }
        }
        else if (message.status !== undefined && message.errorCode !== undefined) {
            const { transactionId, command } = message.customTag === undefined
                ? (0, parseCustomTag_1.parseCustomTag)(null)
                : (0, parseCustomTag_1.parseCustomTag)(message.customTag);
            this.callListener('handleMessage', [{
                    command,
                    error: { errorDescr: message.errorDescr || null, errorCode: message.errorCode },
                    time,
                    transactionId,
                    json,
                    socketId
                }]);
        }
        else {
            this.callListener('handleMessage', [{
                    command: null,
                    error: { errorDescr: 'invalid json schema' },
                    time,
                    transactionId: null,
                    json,
                    socketId
                }]);
        }
    }
}
exports.SocketConnection = SocketConnection;
//# sourceMappingURL=SocketConnection.js.map
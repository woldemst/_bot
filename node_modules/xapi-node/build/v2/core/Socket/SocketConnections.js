"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SocketConnections = void 0;
const Listener_1 = require("../../utils/Listener");
const SocketConnection_1 = require("./SocketConnection");
const Transaction_1 = require("../Transaction");
const Increment_1 = require("../../utils/Increment");
class SocketConnections extends Listener_1.Listener {
    constructor(url, XAPI) {
        super();
        this.connections = {};
        this.transactions = {};
        this.socketIdIncrement = new Increment_1.Increment();
        this.transactionIncrement = new Increment_1.Increment();
        this.url = url;
        this.XAPI = XAPI;
        this.addListener('handleMessage', (params) => {
            var _a, _b;
            const transaction = this.transactions[params.transactionId];
            if (transaction) {
                const elapsedMs = (_b = (_a = transaction.state) === null || _a === void 0 ? void 0 : _a.sent) === null || _b === void 0 ? void 0 : _b.elapsedMs();
                if (params.error) {
                    this.XAPI.counter.count(['error', 'SocketConnections', 'handleMessage']);
                    elapsedMs !== undefined && this.XAPI.counter.count(['data', 'SocketConnection', 'responseTime', 'handleMessage',
                        transaction.state.command || 'undefined_command'], elapsedMs);
                    this.XAPI.counter.count(['data', 'SocketConnection', 'responseTime2', 'handleMessage', transaction.state.command || 'undefined_command'], transaction.state.createdAt.elapsedMs());
                    transaction.reject({
                        error: params.error,
                        jsonReceived: params.time,
                        json: params.json,
                    });
                }
                else {
                    elapsedMs !== undefined && this.XAPI.counter.count(['data', 'SocketConnection', 'responseTime', 'handleMessage',
                        transaction.state.command || 'undefined_command'], elapsedMs);
                    this.XAPI.counter.count(['data', 'SocketConnection', 'responseTime2', 'handleMessage',
                        transaction.state.command || 'undefined_command'], transaction.state.createdAt.elapsedMs());
                    transaction.resolve({
                        returnData: params.returnData,
                        jsonReceived: params.time,
                        json: params.json,
                    });
                    this.callListener(`command_${params.command}`, [params.returnData, params.time, transaction, params.json, params.socketId]);
                }
                delete this.transactions[params.transactionId];
            }
        });
        this.addListener('onClose', (socketId) => {
            for (const t of Object.values(this.transactions)) {
                if (t.state.socketId === socketId) {
                    t.reject({
                        error: new Error('socket closed'),
                        jsonReceived: null,
                        json: null,
                    });
                    if (t.state.transactionId) {
                        delete this.transactions[t.state.transactionId];
                    }
                }
            }
            delete this.connections[socketId];
        });
    }
    onClose(callback) {
        return this.addListener('onClose', (socketId, connection) => {
            callback(socketId, connection);
        });
    }
    onOpen(callback) {
        return this.addListener('onOpen', (socketId, connection) => {
            callback(socketId, connection);
        });
    }
    connect(timeoutMs) {
        const socketId = `${new Date().getTime()}${this.socketIdIncrement.id}`;
        this.connections[socketId] = new SocketConnection_1.SocketConnection(this.url, (listenerId, params) => this.callListener(listenerId, params), socketId, this.XAPI);
        return this.connections[socketId].connect(timeoutMs)
            .then(() => socketId);
    }
    createTransactionId() {
        return `${new Date().getTime()}${this.transactionIncrement.id}`;
    }
    getSocketId() {
        var _a, _b;
        return (_b = (_a = Object.values(this.connections).map((connection) => {
            const times = connection.capacity.filter(i => i.elapsedMs() < 1500);
            return {
                point: times.length <= 4 ? times.length : (5 + (1500 - times[4].elapsedMs())),
                connection,
            };
        }).sort((a, b) => a.point - b.point)[0]) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.socketId;
    }
    sendCommand(command, args = {}, transactionId = null, priority = false, socketId) {
        if (!transactionId) {
            transactionId = this.createTransactionId();
        }
        if (!socketId) {
            socketId = this.getSocketId();
        }
        const t = this.transactions[transactionId] = new Transaction_1.Transaction({
            transactionId,
            command,
            json: JSON.stringify({
                command,
                arguments: Object.keys(args).length === 0 ? undefined : args,
                customTag: `${command}_${transactionId}`,
            }),
            args,
            socketId,
            priority,
        });
        if (socketId) {
            if (this.connections[socketId]) {
                this.XAPI.counter.count(['data', 'SocketConnections', 'sendCommand', command]);
                this.connections[socketId].send(this.transactions[transactionId])
                    .catch(error => {
                    this.XAPI.counter.count(['error', 'SocketConnections', 'sendCommand', command]);
                    if (this.transactions[transactionId]) {
                        this.transactions[transactionId].reject(error);
                        delete this.transactions[transactionId];
                    }
                });
            }
            else {
                this.transactions[transactionId].reject(new Error('invalid socketId'));
                delete this.transactions[transactionId];
            }
        }
        else {
            this.transactions[transactionId].reject(new Error('there is no connected socket'));
            delete this.transactions[transactionId];
        }
        return t.promise;
    }
}
exports.SocketConnections = SocketConnections;
//# sourceMappingURL=SocketConnections.js.map
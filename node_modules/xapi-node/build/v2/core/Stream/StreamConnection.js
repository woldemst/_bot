"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamConnection = void 0;
const WebSocketWrapper_1 = require("../../utils/WebSocketWrapper");
const Time_1 = require("../../utils/Time");
const Transaction_1 = require("../Transaction");
const Timer_1 = require("../../utils/Timer");
const sleep_1 = require("../../utils/sleep");
class StreamConnection {
    constructor(url, session, callListener, streamId, socketId, XAPI) {
        this.connectedTime = null;
        this.lastReceivedMessage = null;
        this.capacity = [];
        this.queue = [];
        this.queueTimer = new Timer_1.Timer();
        this.connectionProgress = null;
        this.disconnectionProgress = null;
        this.session = session;
        this.socketId = socketId;
        this.streamId = streamId;
        this.callListener = callListener;
        this.XAPI = XAPI;
        this.WebSocket = new WebSocketWrapper_1.WebSocketWrapper(url);
        const pingTimer = new Timer_1.Timer();
        this.WebSocket.onOpen(() => {
            var _a, _b;
            this.connectedTime = new Time_1.Time();
            (_a = this.connectionProgress) === null || _a === void 0 ? void 0 : _a.resolve();
            (_b = this.disconnectionProgress) === null || _b === void 0 ? void 0 : _b.reject(new Error('onOpen'));
            pingTimer.setInterval(() => {
                this.ping().catch(() => { });
            }, 14500);
            this.callListener('onOpen', [streamId, this]);
        });
        this.WebSocket.onClose(() => {
            var _a, _b;
            this.connectedTime = null;
            (_a = this.disconnectionProgress) === null || _a === void 0 ? void 0 : _a.resolve();
            (_b = this.connectionProgress) === null || _b === void 0 ? void 0 : _b.reject(new Error('onClose'));
            pingTimer.clear();
            this.callListener('onClose', [streamId, this]);
        });
        this.WebSocket.onMessage((json) => {
            this.lastReceivedMessage = new Time_1.Time();
            try {
                const message = JSON.parse(json.toString().trim());
                this.XAPI.counter.count(['data', 'StreamConnection', 'incomingData'], json.length);
                this.callListener(`command_${message.command}`, [message.data, new Time_1.Time(), json, streamId]);
            }
            catch (e) {
                this.XAPI.counter.count(['error', 'StreamConnection', 'handleMessage']);
                this.callListener(`handleMessage`, [{ error: e, time: new Time_1.Time(), json, streamId }]);
            }
        });
        this.WebSocket.onError((error) => {
            this.connectionProgress && this.connectionProgress.reject(error);
            this.callListener(`handleMessage`, [{ error, time: new Time_1.Time(), json: null, streamId }]);
        });
    }
    get status() {
        return this.WebSocket.connecting ? 'CONNECTING' : (this.WebSocket.status ? 'CONNECTED' : 'DISCONNECTED');
    }
    connect(timeoutMs) {
        if (this.WebSocket.status) {
            throw new Error('already connected');
        }
        if (this.connectionProgress) {
            return this.connectionProgress.promise;
        }
        const t = new Transaction_1.Transaction();
        const timer = new Timer_1.Timer();
        timer.setTimeout(() => {
            var _a;
            (_a = this.connectionProgress) === null || _a === void 0 ? void 0 : _a.reject(new Error('timeout'));
            this.close();
        }, timeoutMs);
        this.connectionProgress = t;
        this.WebSocket.connect();
        return t.promise.catch(e => {
            timer.clear();
            this.connectionProgress = null;
            throw e;
        }).then((r) => {
            timer.clear();
            this.connectionProgress = null;
            this.ping().catch(() => { });
            return r;
        });
    }
    close() {
        if (!this.WebSocket.status && !this.WebSocket.connecting) {
            return Promise.resolve();
        }
        if (this.disconnectionProgress) {
            return this.disconnectionProgress.promise;
        }
        const t = new Transaction_1.Transaction();
        this.disconnectionProgress = t;
        this.WebSocket.close();
        return t.promise.catch(e => {
            this.disconnectionProgress = null;
            throw e;
        }).then((r) => {
            this.disconnectionProgress = null;
            return r;
        });
    }
    ping() {
        return this.sendCommand('ping', {});
    }
    sendCommand(command, completion = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const t = new Transaction_1.Transaction({
                json: JSON.stringify(Object.assign({ command, streamSessionId: this.session }, completion)),
            });
            this.XAPI.counter.count(['data', 'StreamConnection', 'sendCommand', command]);
            return this.send(t);
        });
    }
    cleanQueue() {
        return __awaiter(this, void 0, void 0, function* () {
            for (; this.queue.length > 0;) {
                if (this.capacity[4].elapsedMs() < 1000) {
                    break;
                }
                const jsons = this.queue.splice(0, 1);
                if (jsons.length === 1) {
                    if (jsons[0].transaction.state.createdAt.elapsedMs() > 9000) {
                        jsons[0].transaction.reject(new Error('queue overloaded'));
                    }
                    else {
                        try {
                            this.send(jsons[0].transaction);
                            if (this.queue.length > 0) {
                                yield (0, sleep_1.sleep)(250);
                            }
                        }
                        catch (e) {
                        }
                    }
                }
                else {
                    break;
                }
            }
        });
    }
    callCleaner(elapsedMs) {
        return this.queueTimer.setTimeout(() => __awaiter(this, void 0, void 0, function* () {
            yield this.cleanQueue();
            if (this.queue.length > 0) {
                return yield this.callCleaner(this.capacity[4].elapsedMs());
            }
            return undefined;
        }), 1000 - elapsedMs);
    }
    send(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            if (transaction.state.json.length > 1000) {
                transaction.reject(new Error('Each command invocation should not contain more than 1kB of data.'));
                return transaction.promise;
            }
            try {
                const elapsedMs = this.capacity.length > 4 ? this.capacity[4].elapsedMs() : 1001;
                if (elapsedMs < 1000) {
                    this.queue.push({ transaction });
                    this.queueTimer.isNull() && (yield this.callCleaner(elapsedMs));
                    return transaction.promise;
                }
                const time = new Time_1.Time();
                if (this.capacity.length > 20) {
                    this.capacity = [time, ...this.capacity.slice(0, 4)];
                }
                else {
                    this.capacity.unshift(time);
                }
                yield this.WebSocket.send(transaction.state.json);
                transaction.setState({
                    sent: new Time_1.Time()
                });
                this.XAPI.counter.count(['data', 'StreamConnection', 'outgoingData'], transaction.state.json.length);
                transaction.resolve(time);
            }
            catch (e) {
                transaction.reject(e);
            }
            return transaction.promise;
        });
    }
}
exports.StreamConnection = StreamConnection;
//# sourceMappingURL=StreamConnection.js.map
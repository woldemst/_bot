"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamConnections = void 0;
const Listener_1 = require("../../utils/Listener");
const StreamConnection_1 = require("./StreamConnection");
const Increment_1 = require("../../utils/Increment");
const Time_1 = require("../../utils/Time");
class StreamConnections extends Listener_1.Listener {
    constructor(url, XAPI) {
        super();
        this.connections = {};
        this.subscribes = {};
        this.streamIdIncrement = new Increment_1.Increment();
        this.url = url;
        this.XAPI = XAPI;
        this.addListener('onClose', (streamId) => {
            for (const command of Object.keys(this.subscribes)) {
                for (const [parameter, _streamIdObject] of Object.entries(this.subscribes[command])) {
                    for (const _streamId of Object.keys(_streamIdObject)) {
                        if (_streamId === streamId) {
                            delete this.subscribes[command][parameter][_streamId];
                        }
                    }
                }
            }
            delete this.connections[streamId];
        });
    }
    onClose(callback) {
        return this.addListener('onClose', (streamId, connection) => {
            callback(streamId, connection);
        });
    }
    onOpen(callback) {
        return this.addListener('onOpen', (streamId, connection) => {
            callback(streamId, connection);
        });
    }
    connect(timeoutMs, session, socketId) {
        return __awaiter(this, void 0, void 0, function* () {
            const streamId = `${new Date().getTime()}${this.streamIdIncrement.id}`;
            this.connections[streamId] = new StreamConnection_1.StreamConnection(this.url, session, (listenerId, params) => this.callListener(listenerId, params), streamId, socketId, this.XAPI);
            yield this.connections[streamId].connect(timeoutMs);
            return streamId;
        });
    }
    getStreamId(command, completion = {}) {
        var _a, _b, _c, _d, _e;
        if (this.subscribes[command]) {
            if (this.subscribes[command][JSON.stringify(completion)]) {
                const streamIds = Object.keys(this.subscribes[command][JSON.stringify(completion)]);
                for (const streamId of streamIds) {
                    if (((_a = this.connections[streamId]) === null || _a === void 0 ? void 0 : _a.status) === 'CONNECTED') {
                        return streamId;
                    }
                    else {
                        delete this.subscribes[command][JSON.stringify(completion)][streamId];
                    }
                }
            }
            else if (this.subscribes[command]['{}']) {
                const streamIds = Object.keys(this.subscribes[command]['{}']);
                for (const streamId of streamIds) {
                    if (((_b = this.connections[streamId]) === null || _b === void 0 ? void 0 : _b.status) === 'CONNECTED') {
                        return streamId;
                    }
                    else {
                        delete this.subscribes[command]['{}'][streamId];
                    }
                }
            }
            else if (Object.keys(this.subscribes[command])[0]) {
                const firstKey = Object.keys(this.subscribes[command])[0];
                const streamIds = Object.keys(this.subscribes[command][firstKey]);
                for (const streamId of streamIds) {
                    if (((_c = this.connections[streamId]) === null || _c === void 0 ? void 0 : _c.status) === 'CONNECTED') {
                        return streamId;
                    }
                    else {
                        delete this.subscribes[command][firstKey][streamId];
                    }
                }
            }
        }
        return (_e = (_d = Object.values(this.connections).map((connection) => {
            const times = connection.capacity.filter(i => i.elapsedMs() < 1500);
            return {
                point: times.length <= 4 ? times.length : (5 + (1500 - times[0].elapsedMs())),
                connection,
            };
        }).sort((a, b) => a.point - b.point)[0]) === null || _d === void 0 ? void 0 : _d.connection) === null || _e === void 0 ? void 0 : _e.streamId;
    }
    sendSubscribe(command, completion = {}, streamId = undefined) {
        if (!streamId) {
            streamId = this.getStreamId(command);
            if (!streamId) {
                throw new Error('there is no connected stream ' + JSON.stringify({ streamId }));
            }
        }
        if (!this.connections[streamId]) {
            throw new Error('there is no connected stream ' + JSON.stringify({ streamId }));
        }
        const promise = this.connections[streamId].sendCommand('get' + command, completion);
        if (this.subscribes[command]) {
            const completionKey = JSON.stringify(completion);
            if (!this.subscribes[command][completionKey]) {
                this.subscribes[command][completionKey] = {};
            }
            this.subscribes[command][completionKey][streamId] = new Time_1.Time();
        }
        else {
            this.subscribes[command] = {
                [JSON.stringify(completion)]: { streamId: new Time_1.Time() }
            };
        }
        return promise;
    }
    sendUnsubscribe(command, completion = {}) {
        if (!this.subscribes[command]) {
            return Promise.resolve(undefined);
        }
        const streamIds = Object.keys(this.subscribes[command][JSON.stringify(completion)]);
        if (streamIds.length === 0) {
            return Promise.resolve(undefined);
        }
        return Promise.allSettled(streamIds
            .filter((streamId) => this.connections[streamId])
            .map((streamId) => this.connections[streamId].sendCommand('stop' + command, completion)));
    }
}
exports.StreamConnections = StreamConnections;
//# sourceMappingURL=StreamConnections.js.map
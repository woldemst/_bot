"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Trading = void 0;
const Time_1 = require("../../utils/Time");
const OpenPosition_1 = require("./OpenPosition");
const LimitPosition_1 = require("./LimitPosition");
const Enum_1 = require("../../interface/Enum");
const TradeRecord_1 = require("../TradeRecord");
const getObjectChanges_1 = require("../../utils/getObjectChanges");
const Timer_1 = require("../../utils/Timer");
const getPositionType_1 = require("../../utils/getPositionType");
const sleep_1 = require("../../utils/sleep");
const Object_1 = require("../../utils/Object");
class Trading {
    constructor(XAPI, callListener) {
        this._positions = null;
        this._positionsUpdated = null;
        this.pendingOrders = {};
        this.XAPI = XAPI;
        this.XAPI.Stream.listen.getTrades((t, time) => {
            if (t.cmd === Enum_1.CMD_FIELD.BALANCE || t.cmd === Enum_1.CMD_FIELD.CREDIT) {
                callListener('onTransactionUpdate', [{
                        key: 'BALANCE',
                        trade: t,
                    }]);
            }
            else if (t.type === Enum_1.TYPE_FIELD.PENDING &&
                t.cmd !== Enum_1.CMD_FIELD.BUY_LIMIT &&
                t.cmd !== Enum_1.CMD_FIELD.SELL_LIMIT &&
                t.cmd !== Enum_1.CMD_FIELD.BUY_STOP &&
                t.cmd !== Enum_1.CMD_FIELD.SELL_STOP) {
                callListener('onTransactionUpdate', [{
                        key: 'PENDING',
                        trade: new TradeRecord_1.TradeRecord(t),
                    }]);
            }
            else if (t.state === 'Deleted') {
                if (!this._positions) {
                    return;
                }
                if (this._positions[t.position] !== undefined && this._positions[t.position].value !== null) {
                    this._positions[t.position] = { value: null, lastUpdated: time };
                    callListener('onTransactionUpdate', [{
                            key: 'DELETE',
                            trade: new TradeRecord_1.TradeRecord(t),
                        }]);
                }
            }
            else {
                if (!this._positions) {
                    return;
                }
                if (this._positions[t.position] === undefined || this._positions[t.position].value !== null) {
                    if (this._positions[t.position] !== undefined) {
                        const { value } = this._positions[t.position];
                        if (value) {
                            const changes = (0, getObjectChanges_1.getObjectChanges)(value, new TradeRecord_1.TradeRecord(t));
                            if (Object.keys(changes).length > 0) {
                                callListener('onTransactionUpdate', [{
                                        key: 'MODIFY',
                                        trade: new TradeRecord_1.TradeRecord(t),
                                    }]);
                            }
                        }
                    }
                    else {
                        callListener('onTransactionUpdate', [{
                                key: 'CREATED',
                                trade: new TradeRecord_1.TradeRecord(t),
                            }]);
                    }
                    this._positions[t.position] = { value: new TradeRecord_1.TradeRecord(t), lastUpdated: time };
                }
            }
        });
        this.XAPI.Socket.listen.getTrades((data, time, transaction) => {
            const sent = transaction.state.createdAt;
            if (sent && sent.elapsedMs() < 1000) {
                const obj = {};
                for (const t of data) {
                    if (!this._positions || this._positions[t.position] === undefined || this._positions[t.position].value !== null) {
                        obj[t.position] = {
                            value: new TradeRecord_1.TradeRecord(t),
                            lastUpdated: sent,
                        };
                    }
                }
                if (this._positions) {
                    for (const t of Object.values(this._positions)) {
                        if (obj[t.position] === undefined && t.value !== null) {
                            if (t.lastUpdated.elapsedMs() <= 1000) {
                                obj[t.position] = t;
                            }
                        }
                    }
                }
                this._positions = obj;
                this._positionsUpdated = new Time_1.Time();
            }
        });
        this.XAPI.Socket.listen.tradeTransactionStatus((returnData, time, transaction) => {
            const { resolve, reject } = this.pendingOrders[returnData.order] || {};
            if (resolve !== undefined &&
                reject !== undefined &&
                returnData.requestStatus !== Enum_1.REQUEST_STATUS_FIELD.PENDING) {
                delete this.pendingOrders[returnData.order];
                if (returnData.requestStatus === Enum_1.REQUEST_STATUS_FIELD.ACCEPTED) {
                    resolve(returnData);
                }
                else {
                    reject(returnData);
                }
            }
        });
        this.XAPI.Stream.listen.getTradeStatus((s, time) => {
            if (s.requestStatus !== Enum_1.REQUEST_STATUS_FIELD.PENDING) {
                const { resolve, reject } = this.pendingOrders[s.order] || {};
                delete s.price;
                if (resolve !== undefined && reject !== undefined) {
                    delete this.pendingOrders[s.order];
                    if (s.requestStatus === Enum_1.REQUEST_STATUS_FIELD.ACCEPTED) {
                        resolve(s);
                    }
                    else {
                        reject(s);
                    }
                }
                else {
                    this.pendingOrders[s.order] = {
                        order: s.order,
                        reject: undefined,
                        resolve: undefined,
                        data: s,
                        createdAt: time,
                    };
                }
            }
        });
        const t = new Timer_1.Timer();
        this.XAPI.onClose(() => {
            if (Object.values(this.XAPI.Stream.connections).every((c) => c.status === 'DISCONNECTED')) {
                t.clear();
            }
        });
        const updateStuckOrders = () => __awaiter(this, void 0, void 0, function* () {
            if ((0, Object_1.isEmpty)(this.pendingOrders)) {
                return;
            }
            const start = new Time_1.Time();
            if (Object.values(this.XAPI.Socket.connections).some((c) => c.lastReceivedMessage !== null && c.status === 'CONNECTED')) {
                for (const order of Object.values(this.pendingOrders)) {
                    if (order.createdAt.elapsedMs() > 90000) {
                        order === null || order === void 0 ? void 0 : order.reject(new Error('timeout: 90000ms'));
                        delete this.pendingOrders[order.order];
                        return;
                    }
                    if (order.createdAt.elapsedMs() > 5000 && order.resolve !== undefined && order.reject !== undefined) {
                        yield this.XAPI.Socket.send.tradeTransactionStatus(order.order);
                    }
                    if (start.elapsedMs() > 5000) {
                        return;
                    }
                }
            }
        });
        this.XAPI.Stream.onOpen(() => {
            if (t.isNull() && Object.values(this.XAPI.Socket.connections).some((c) => c.lastReceivedMessage !== null && c.status !== 'DISCONNECTED')) {
                t.setInterval(() => {
                    updateStuckOrders().catch(error => {
                        this.XAPI.logger.warn({
                            source: 'src/v2/core/Trading/Trading.ts',
                            function: 'updateStuckOrders',
                            data: {
                                error
                            }
                        });
                    });
                }, 5100);
            }
        });
        this.XAPI.Socket.onOpen(() => {
            if (t.isNull() && Object.values(this.XAPI.Socket.connections).some((c) => c.lastReceivedMessage !== null && c.status !== 'DISCONNECTED')) {
                t.setInterval(() => {
                    updateStuckOrders().catch(error => {
                        this.XAPI.logger.warn({
                            source: 'src/v2/core/Trading/Trading.ts',
                            function: 'updateStuckOrders',
                            data: {
                                error
                            }
                        });
                    });
                }, 5100);
            }
        });
    }
    buy({ symbol, volume = 0.01, tp = 0, sl = 0, customComment = null, limit = undefined, expiration = undefined }) {
        this.XAPI.logger.transaction({ source: 'src/v2/core/Trading/Trading.ts', function: 'buy', data: {
                input: [{ symbol, volume, tp, sl, customComment, limit, expiration }],
                state: 'before'
            } });
        return this.tradeTransaction({
            cmd: limit == undefined ? Enum_1.CMD_FIELD.BUY : Enum_1.CMD_FIELD.BUY_LIMIT,
            type: Enum_1.TYPE_FIELD.OPEN,
            order: 0,
            symbol,
            volume,
            tp,
            sl,
            customComment,
            expiration: expiration !== undefined ? expiration : (limit == undefined ? new Date().getTime() + 10000 : new Date().getTime() + 60000 * 60 * 24),
            offset: 0,
            price: limit == undefined ? 1 : limit,
        });
    }
    sell({ symbol, volume = 0.01, tp = 0, sl = 0, customComment = null, limit = undefined, expiration = undefined }) {
        this.XAPI.logger.transaction({ source: 'src/v2/core/Trading/Trading.ts', function: 'sell', data: {
                input: [{ symbol, volume, tp, sl, customComment, limit, expiration }],
                state: 'before'
            } });
        return this.tradeTransaction({
            cmd: limit == undefined ? Enum_1.CMD_FIELD.SELL : Enum_1.CMD_FIELD.SELL_LIMIT,
            type: Enum_1.TYPE_FIELD.OPEN,
            order: 0,
            symbol,
            volume,
            tp,
            sl,
            customComment,
            expiration: expiration !== undefined ? expiration : (limit == undefined ? new Date().getTime() + 10000 : new Date().getTime() + 60000 * 60 * 24),
            offset: 0,
            price: limit == undefined ? 1 : limit,
        });
    }
    modify(modify) {
        var _a, _b;
        this.XAPI.logger.transaction({ source: 'src/v2/core/Trading/Trading.ts', function: 'modify', data: {
                input: [modify],
                state: 'before'
            } });
        const position = (_a = this.positions) === null || _a === void 0 ? void 0 : _a.find(x => x.position === modify.order);
        if (!position) {
            this.XAPI.logger.transaction({ source: 'src/v2/core/Trading/Trading.ts', function: 'modify', data: {
                    input: [modify],
                    result: { error: { message: `position is not found by id (${modify.order})` } },
                    state: 'end'
                } });
            return Promise.reject(new Error(`position is not found by id (${modify.order})`));
        }
        const tp = modify.tp === null ? undefined : (modify.tp === undefined ? position.tp : modify.tp);
        const sl = modify.sl === null ? undefined : (modify.sl === undefined ? position.sl : modify.sl);
        const offset = modify.offset === null ? undefined : (modify.offset === undefined ? position.offset : modify.offset);
        const volume = modify.volume === undefined ? position.volume : modify.volume;
        const expiration = modify.expiration === undefined
            ? (position.position_type === Enum_1.PositionType.limit ? position.expiration : (((_b = this.XAPI.Time) === null || _b === void 0 ? void 0 : _b.getTime()) || new Date().getTime()) + 10000)
            : (modify.expiration === null ? undefined : modify.expiration);
        return this.tradeTransaction({
            cmd: position.cmd,
            type: Enum_1.TYPE_FIELD.MODIFY,
            symbol: position.symbol,
            tp,
            sl,
            offset,
            expiration: expiration === null ? undefined : expiration,
            order: modify.order,
            price: modify.price === undefined && position.position_type === Enum_1.PositionType.limit ? position.open_price : modify.price,
            customComment: modify.customComment,
            volume,
        });
    }
    close({ order, volume, customComment, expiration }) {
        var _a, _b;
        this.XAPI.logger.transaction({ source: 'src/v2/core/Trading/Trading.ts', function: 'close', data: {
                input: { order, volume, customComment, expiration },
                state: 'before'
            } });
        const trade = (_a = this.positions) === null || _a === void 0 ? void 0 : _a.find(x => x.position === order);
        if (!trade) {
            this.XAPI.logger.transaction({ source: 'src/v2/core/Trading/Trading.ts', function: 'close', data: {
                    input: { order, volume, customComment, expiration },
                    result: { error: { message: `position is not found by id (${order})` } },
                    state: 'end'
                } });
            return {
                transaction: Promise.reject(new Error(`position is not found by id (${order})`)),
                transactionStatus: Promise.reject(new Error(`position is not found by id (${order})`)),
            };
        }
        const { cmd, symbol } = trade;
        return this.tradeTransaction({
            cmd: (cmd === Enum_1.CMD_FIELD.BUY) ? Enum_1.CMD_FIELD.SELL : Enum_1.CMD_FIELD.BUY,
            type: (0, getPositionType_1.getPositionType)(trade) === Enum_1.PositionType.limit ? Enum_1.TYPE_FIELD.DELETE : Enum_1.TYPE_FIELD.CLOSE,
            tp: 0,
            sl: 0,
            offset: 0,
            expiration: expiration === undefined ? (((_b = this.XAPI.Time) === null || _b === void 0 ? void 0 : _b.getTime()) || new Date().getTime()) + 10000 : expiration,
            order,
            price: 1.0,
            symbol,
            customComment: !customComment ? '' : customComment,
            volume: (volume === undefined) ? trade.volume : Math.min(volume, trade.volume)
        });
    }
    get openPositions() {
        var _a;
        return ((_a = this.positions) === null || _a === void 0 ? void 0 : _a.filter(t => t.position_type === Enum_1.PositionType.open).map(i => new OpenPosition_1.OpenPosition(this.XAPI, i))) || null;
    }
    get limitPositions() {
        var _a;
        return ((_a = this.positions) === null || _a === void 0 ? void 0 : _a.filter(t => t.position_type === Enum_1.PositionType.limit).map(i => new LimitPosition_1.LimitPosition(this.XAPI, i))) || null;
    }
    get positions() {
        return this._positions ? Object.values(this._positions)
            .filter(t => t.value !== null &&
            (t.value.position_type === Enum_1.PositionType.limit || t.value.position_type === Enum_1.PositionType.open))
            .map(t => t.value) : null;
    }
    get positionsUpdated() {
        return this._positionsUpdated;
    }
    tradeTransaction(tradeTransInfo) {
        var _a, _b, _c;
        let position = undefined;
        if (!tradeTransInfo.cmd || !tradeTransInfo.symbol) {
            if (tradeTransInfo.type === Enum_1.TYPE_FIELD.MODIFY) {
                position = (_a = this.positions) === null || _a === void 0 ? void 0 : _a.find(p => p.position === tradeTransInfo.order);
                if (position === undefined) {
                    const error = !this.XAPI.Stream.subscribes['TradeStatus']
                        ? `type === MODIFY in tradeTransaction will not work with missing parameters, you should subscribe TradeStatus in stream`
                        : `type === MODIFY in tradeTransaction orderId = ${tradeTransInfo.order} not found, possible open orderIds example: ${(((_b = this.positions) === null || _b === void 0 ? void 0 : _b.map(p => p.position).slice(0, 10)) || []).join(',')}${((_c = this.positions) === null || _c === void 0 ? void 0 : _c.length) || 0 > 10 ? ',...' : ''}`;
                    throw new Error(error);
                }
            }
        }
        const tradeTransInfoParams = {
            cmd: tradeTransInfo.cmd || (position === null || position === void 0 ? void 0 : position.cmd),
            customComment: tradeTransInfo.customComment,
            expiration: tradeTransInfo.expiration,
            offset: tradeTransInfo.offset,
            order: tradeTransInfo.order,
            price: tradeTransInfo.price,
            sl: tradeTransInfo.sl,
            symbol: tradeTransInfo.symbol || (position === null || position === void 0 ? void 0 : position.symbol),
            tp: tradeTransInfo.tp,
            type: tradeTransInfo.type,
            volume: tradeTransInfo.volume === undefined
                ? position
                    ? parseFloat(position.volume.toFixed(2))
                    : undefined
                : parseFloat(tradeTransInfo.volume.toFixed(2)),
        };
        const transaction = this.XAPI.Socket.send.tradeTransaction(tradeTransInfoParams);
        return {
            transaction,
            transactionStatus: new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const { data: { returnData, jsonReceived: time } } = yield transaction;
                    const { data } = this.pendingOrders[returnData.order] || {};
                    if (!data) {
                        this.pendingOrders[returnData.order] = {
                            order: returnData.order,
                            resolve,
                            reject,
                            data: null,
                            createdAt: time,
                        };
                        if (!this.XAPI.Stream.subscribes['TradeStatus']) {
                            yield (0, sleep_1.sleep)(499);
                            let { reject: reject2, resolve: resolve2 } = this.pendingOrders[returnData.order];
                            if (resolve2 !== undefined && reject2 !== undefined) {
                                const r = (yield this.XAPI.Socket.send.tradeTransactionStatus(returnData.order)).data;
                                const status = r.returnData.requestStatus;
                                if (status === Enum_1.REQUEST_STATUS_FIELD.ACCEPTED) {
                                    delete this.pendingOrders[returnData.order];
                                    resolve(r.returnData);
                                }
                                else if (status !== Enum_1.REQUEST_STATUS_FIELD.PENDING) {
                                    delete this.pendingOrders[returnData.order];
                                    reject(r.returnData);
                                }
                            }
                        }
                    }
                    else {
                        if (data.requestStatus === Enum_1.REQUEST_STATUS_FIELD.ACCEPTED) {
                            delete this.pendingOrders[returnData.order];
                            resolve(data);
                        }
                        else if (data.requestStatus === Enum_1.REQUEST_STATUS_FIELD.PENDING) {
                            this.pendingOrders[returnData.order].resolve = resolve;
                            this.pendingOrders[returnData.order].reject = reject;
                        }
                        else {
                            delete this.pendingOrders[returnData.order];
                            reject(data);
                        }
                    }
                }
                catch (e) {
                    reject(e);
                }
            }))
        };
    }
}
exports.Trading = Trading;
//# sourceMappingURL=Trading.js.map
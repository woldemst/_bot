"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XAPI = exports.DefaultRateLimit = exports.DefaultHost = void 0;
const Listener_1 = require("../utils/Listener");
const Socket_1 = require("./Socket/Socket");
const Stream_1 = require("./Stream/Stream");
const Enum_1 = require("../interface/Enum");
const Trading_1 = require("./Trading/Trading");
const Logger_1 = require("../utils/Logger");
const Counter_1 = require("../utils/Counter");
exports.DefaultHost = 'ws.xapi.pro';
exports.DefaultRateLimit = 850;
class XAPI extends Listener_1.Listener {
    constructor(config, logger, counter) {
        super();
        this._serverTime = null;
        this.connections = {};
        this.logger = logger || new Logger_1.Logger();
        this.counter = counter || new Counter_1.Counter();
        const accountType = config.accountType || config.type || '';
        if (!['real', 'demo'].includes(accountType)) {
            throw new Error('invalid "accountType" config it should be demo or real');
        }
        if (config.rateLimit === undefined) {
            config.rateLimit = exports.DefaultRateLimit;
        }
        if (config.host === undefined) {
            config.host = exports.DefaultHost;
        }
        if (config.tradingDisabled === undefined) {
            config.tradingDisabled = false;
        }
        this.Socket = new Socket_1.Socket(this, accountType, config.host, config.tradingDisabled, config.accountId, config.password, config.appName);
        this.Stream = new Stream_1.Stream(accountType, config.host, this);
        this.trading = new Trading_1.Trading(this, (listenerId, params = []) => this.callListener(listenerId, params));
        this.Stream.onClose((streamId, connection) => {
            this.logger.debug({ source: 'src/v2/core/XAPI.ts', function: 'constructor', data: {
                    'this.Stream.onClose': { streamId }
                } });
            if (connection.socketId && this.Socket.connections[connection.socketId]) {
                this.Socket.connections[connection.socketId].close();
            }
            delete this.Stream.connections[streamId];
        });
        this.Socket.onClose((socketId, connection) => {
            this.logger.debug({ source: 'src/v2/core/XAPI.ts', function: 'constructor', data: {
                    'this.Socket.onClose': { socketId }
                } });
            if (connection.streamId && this.Stream.connections[connection.streamId]) {
                this.Stream.connections[connection.streamId].close();
            }
            delete this.Socket.connections[socketId];
            delete this.connections[socketId];
        });
        this.Socket.listen.getServerTime((data, time, transaction, jsonString, socketId) => {
            var _a;
            if ((_a = transaction === null || transaction === void 0 ? void 0 : transaction.state) === null || _a === void 0 ? void 0 : _a.sent) {
                const dif = time.getDifference(transaction.state.sent);
                if (data.time % 1 !== 0 || data.time < 1699184959218) {
                    this.logger.warn({ source: 'src/v2/core/XAPI.ts', function: 'constructor', data: {
                            'this.Socket.listen.getServerTime': { socketId },
                            message: 'invalid data.time, this._serverTime variable change skipped'
                        } });
                    return;
                }
                this._serverTime = {
                    timestamp: data.time,
                    ping: dif,
                    received: time,
                };
            }
        });
    }
    get Time() {
        if (!this._serverTime) {
            return null;
        }
        return new Date(this._serverTime.received.elapsedMs() + this._serverTime.timestamp + this._serverTime.ping);
    }
    onClose(callback) {
        return [
            this.Stream.onClose((streamId, connection) => {
                if (connection.socketId && this.Socket.connections[connection.socketId]) {
                    callback({
                        socket: { socketId: connection.socketId, connection: this.Socket.connections[connection.socketId], },
                        stream: { streamId, connection, },
                    });
                }
                else {
                    callback({
                        socket: { socketId: connection.socketId, connection: null, },
                        stream: { streamId, connection, },
                    });
                }
            }),
            this.Socket.onClose((socketId, connection) => {
                if (connection.streamId && this.Stream.connections[connection.streamId]) {
                    callback({
                        socket: { socketId, connection, },
                        stream: { streamId: connection.streamId, connection: this.Stream.connections[connection.streamId], },
                    });
                }
                else {
                    callback({
                        socket: { socketId, connection, },
                        stream: { streamId: connection.streamId, connection: null },
                    });
                }
            }),
        ];
    }
    onTransactionUpdate(callback, key = null) {
        return this.addListener('onTransactionUpdate', callback, key);
    }
    connect({ timeout } = { timeout: 15000 }) {
        this.logger.debug({ source: 'src/v2/core/XAPI.ts', function: 'connect', data: {
                input: { timeout }
            } });
        if (isNaN(timeout) || timeout < 0) {
            throw new Error('invalid "timeout" parameter');
        }
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            let socketId;
            let streamId;
            try {
                socketId = yield this.Socket.connect(timeout);
                const streamSessionId = (_b = (_a = (yield this.Socket.send.login(socketId)).data) === null || _a === void 0 ? void 0 : _a.returnData) === null || _b === void 0 ? void 0 : _b.streamSessionId;
                if (!streamSessionId) {
                    throw new Error('invalid streamSessionId');
                }
                this.Socket.connections[socketId].loggedIn = true;
                const result = yield Promise.allSettled([
                    this.trading.positionsUpdated === null ? this.Socket.send.getTrades() : Promise.resolve(undefined),
                    this._serverTime === null ? this.Socket.send.getServerTime() : Promise.resolve(undefined),
                    this.Stream.connect(timeout, streamSessionId, socketId),
                ]);
                if (result[2].value) {
                    streamId = result[2].value;
                }
                const error = result.some(i => i.status !== 'fulfilled');
                if (error) {
                    throw error.reason;
                }
                if (!streamId || !this.Stream.connections[streamId]) {
                    throw new Error('Stream not exists after Socket connected');
                }
                if (!this.Socket.connections[socketId]) {
                    throw new Error('Socket not exists after Stream connected');
                }
                this.Socket.connections[socketId].streamId = streamId;
                this.logger.debug({ source: 'src/v2/core/XAPI.ts', function: 'connect', data: {
                        created: { socketId, streamId }
                    } });
                this.connections[socketId] = { socket: this.Socket.connections[socketId], stream: this.Stream.connections[socketId] };
                resolve({ socketId, streamId });
            }
            catch (e) {
                reject(e);
                yield Promise.allSettled([
                    socketId ? (_c = this.Socket.connections[socketId]) === null || _c === void 0 ? void 0 : _c.close() : Promise.resolve(),
                    streamId ? (_d = this.Stream.connections[streamId]) === null || _d === void 0 ? void 0 : _d.close() : Promise.resolve(),
                ]);
                this.logger.debug({ source: 'src/v2/core/XAPI.ts', function: 'connect', error: e });
            }
        }));
    }
    getAccountCurrencyValue(anotherCurrency) {
        return Enum_1.Currency2Pair[anotherCurrency] === undefined
            ? Promise.reject(new Error(anotherCurrency + ' is not relevant currency'))
            : Promise.all([
                this.Socket.send.getSymbol(Enum_1.Currency2Pair[anotherCurrency]),
                this.Socket.send.getProfitCalculation(1, Enum_1.CMD_FIELD.BUY, 0, Enum_1.Currency2Pair[anotherCurrency], 1),
            ]).then(values => {
                return values[1].data.returnData.profit / values[0].data.returnData.contractSize;
            });
    }
    getPriceHistory({ symbol, period = Enum_1.PERIOD_FIELD.PERIOD_M1, ticks = null, startUTC = null, socketId = undefined, }) {
        var _a;
        return (startUTC !== null && ticks === null
            ? this.Socket.send.getChartLastRequest(period, startUTC, symbol, socketId)
            : this.Socket.send.getChartRangeRequest(0, period, startUTC !== null ? startUTC : (((_a = this.Time) === null || _a === void 0 ? void 0 : _a.getTime()) || new Date().getTime()), symbol, ticks === null ? -Enum_1.CHART_RATE_LIMIT_BY_PERIOD[Enum_1.PERIOD_FIELD[period]] : ticks, socketId)).then(({ data }) => ({
            symbol,
            period,
            candles: data.returnData.rateInfos.map(candle => ({
                timestamp: candle.ctm,
                open: Math.round(candle.open),
                close: Math.round(Math.round(candle.close) + Math.round(candle.open)),
                low: Math.round(Math.round(candle.low) + Math.round(candle.open)),
                high: Math.round(Math.round(candle.high) + Math.round(candle.open)),
                volume: candle.vol,
            })),
            digits: data.returnData.digits,
            json: data.json,
        }));
    }
    disconnect(socketId = undefined) {
        this.logger.debug({ source: 'src/v2/core/XAPI.ts', function: 'disconnect', data: {
                input: { socketId }
            } });
        const promiseList = [];
        if (socketId) {
            for (const i of Object.values(this.Socket.connections)) {
                if (i.socketId === socketId) {
                    promiseList.push(i.close());
                    if (i.streamId) {
                        for (const k of Object.values(this.Stream.connections)) {
                            if (k.streamId === i.streamId) {
                                promiseList.push(k.close());
                                break;
                            }
                        }
                    }
                    break;
                }
            }
        }
        else {
            for (const i of Object.values(this.Socket.connections)) {
                promiseList.push(i.close());
            }
            for (const i of Object.values(this.Stream.connections)) {
                promiseList.push(i.close());
            }
        }
        return Promise.allSettled(promiseList);
    }
}
exports.XAPI = XAPI;
//# sourceMappingURL=XAPI.js.map